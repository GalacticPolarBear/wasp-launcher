{$DEFINE WS_ASYNC_INCLUDED}
{$IFNDEF WS_LAUNCHER}
  {$I core.simba}
{$ENDIF}

type
  EMonitorState = (NONE, DOWNLOAD, UNZIP, CLEAN);

  TMonitor = record
    Package: String;
    CurrentFile: String;
    State: EMonitorState;
    IsSetup: Boolean;

    Caption: TLabel;
    Button: TButton;
    Timer: TTimer;
  end;

  TWaspAsync = record
    Path: String;
  end;

procedure TWaspAsync.Write(name, content: String);
begin
  if not WriteFileContents(Self.Path + name, content, False) then
    TerminateScript('WaspAsync: Failed to write async file: ' + name);
end;

procedure TWaspAsync.Run(name: String; params: TStringArray);
begin
  if not name.EndsWith('.simba') then
    name += '.simba';
  RunScript(Self.Path + name, params);
end;


function TWaspAsync.GetDownloaderContent(): String;
begin
  Result += "var" + LineEnding;
  Result += "  timeout: TTimer;" + LineEnding;
  Result += "  http: Int32;" + LineEnding;
  Result += "  url, pkg: String;" + LineEnding;
  Result += "  t: UInt64;" + LineEnding + LineEnding;
  Result += "procedure OnTimer({$H-}sender: TObject);{$H+}" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  WriteLn('[AsyncDownloader]: Downloading ', pkg, '...');" + LineEnding + LineEnding;
  Result += "  if GetTickCount() > t then" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    WriteLn('[AsyncDownloader]: If this has taken over 5 minutes please restart Simba.');" + LineEnding;
  Result += "    WriteLn('[AsyncDownloader]: If you are rate limited you need to wait 1 hour.');" + LineEnding;
  Result += "    t := GetTickCount() + 120000;" + LineEnding;
  Result += "  end;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure Free();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  timeout.setEnabled(False);" + LineEnding;
  Result += "  timeout.Free();" + LineEnding;
  Result += "  FreeHTTPClient(http);" + LineEnding;
  Result += "  CloseFile(CreateFile({$macro CURRENT_DIRECTORY} + 'downloader-' + LowerCase(pkg) + '.done'));" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure RunTimer();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  timeout.setOnTimer(@OnTimer);" + LineEnding;
  Result += "  timeout.setEnabled(True);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  url := GetProcessParameter('url');" + LineEnding;
  Result += "  pkg := GetProcessParameter('pkg');" + LineEnding + LineEnding;
  Result += "  if FileExists({$macro CURRENT_DIRECTORY} + 'downloader-' + LowerCase(pkg) + '.done') then" + LineEnding;
  Result += "    DeleteFile({$macro CURRENT_DIRECTORY} + 'downloader-' + LowerCase(pkg) + '.done');" + LineEnding + LineEnding;
  Result += "  timeout.Init(nil);" + LineEnding;
  Result += "  timeout.SetName('downloader_timeout');" + LineEnding;
  Result += "  timeout.SetInterval(20000);" + LineEnding;
  Result += "  http := InitializeHTTPClient(True);" + LineEnding;
  Result += "  Sync(@RunTimer);" + LineEnding;
  Result += "  AddOnTerminate(@Free);" + LineEnding + LineEnding;
  Result += "  WriteLn('[AsyncDownloader]: Downloading ', pkg, ', this might take a while.');" + LineEnding;
  Result += "  t := GetTickCount() + 120000;" + LineEnding + LineEnding;
  Result += "  try" + LineEnding;
  Result += "    if GetHTTPPageEx(http, url, GetProcessParameter('destination')) = 200 then" + LineEnding;
  Result += "      WriteLn('[AsyncDownloader]: ' + pkg + ' downloaded.')" + LineEnding;
  Result += "    else" + LineEnding;
  Result += "      WriteLn('[AsyncDownloader]: Failed to download: ' + url);" + LineEnding;
  Result += "  except" + LineEnding;
  Result += "    WriteLn('[AsyncDownloader]: Error: ', GetExceptionMessage());" + LineEnding;
  Result += "  end;" + LineEnding;
  Result += "end;" + LineEnding;
end;

function TWaspAsync.GetUnzipperContent(): String;
begin
  Result += "var" + LineEnding;
  Result += "  path, name: String;" + LineEnding + LineEnding;
  Result += "procedure Free();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  CloseFile(CreateFile({$macro CURRENT_DIRECTORY} + 'unzipper-' + LowerCase(name) + '.done'));" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  path := GetProcessParameter('path');" + LineEnding;
  Result += "  name := GetProcessParameter('name');" + LineEnding + LineEnding;
  Result += "  if FileExists({$macro CURRENT_DIRECTORY} + 'downloader-' + LowerCase(name) + '.done') then" + LineEnding;
  Result += "    DeleteFile({$macro CURRENT_DIRECTORY} + 'downloader-' + LowerCase(name) + '.done');" + LineEnding + LineEnding;
  Result += "  AddOnTerminate(@Free);" + LineEnding + LineEnding;
  Result += "  WriteLn('[AsyncUnzipper]: Unzipping ', name, ', this might take a while.');" + LineEnding + LineEnding;
  Result += "  try" + LineEnding;
  Result += "    UnZipFile(path + name + '.zip', path + name);" + LineEnding;
  Result += "    DeleteFile(path + name + '.zip');" + LineEnding;
  Result += "  except" + LineEnding;
  Result += "    WriteLn('[AsyncUnzipper]: Error: ', GetExceptionMessage());" + LineEnding;
  Result += "  end;" + LineEnding;
  Result += "end;" + LineEnding;
end;

function TWaspAsync.GetMoverContent(): String;
begin
  Result += "const" + LineEnding;
  Result += "  SEP = DirectorySeparator;" + LineEnding + LineEnding;
  Result += "procedure TerminateScript(reason: String); overload;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  WriteLn('[AsyncMover]: Terminating: ' + reason);" + LineEnding;
  Result += "  TerminateScript();" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "function TStringArray.Find(const value: String): Integer; constref;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for Result := 0 to High(Self) do" + LineEnding;
  Result += "    if value = Self[Result] then" + LineEnding;
  Result += "      Exit;" + LineEnding;
  Result += "  Result := -1;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TStringArray.Contains(const value: String): Boolean; constref;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Result := Self.Find(value) > -1;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TStringArray.Merge(glue:String=''): String; constref;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  i:Int32;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if Length(Self) = 0 then" + LineEnding;
  Result += "    Exit();" + LineEnding + LineEnding;
  Result += "  Result := Self[0];" + LineEnding;
  Result += "  for i:=1 to High(Self) do" + LineEnding;
  Result += "    Result += glue + Self[i];" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function BackupFile(filePath: String): Boolean;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  f: Int32;" + LineEnding;
  Result += "  contents: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  f := OpenFile(filePath, False);" + LineEnding;
  Result += "  if not ReadFileString(f, contents, FileSize(f)) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  CloseFile(f);" + LineEnding;
  Result += "  Result := WriteFileContents(filePath + '.bak', contents, False);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function RestoreFile(filePath: String): Boolean;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  f: Int32;" + LineEnding;
  Result += "  contents: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  f := OpenFile(filePath + '.bak', False);" + LineEnding;
  Result += "  if not ReadFileString(f, contents, FileSize(f)) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  CloseFile(f);" + LineEnding;
  Result += "  Result := WriteFileContents(filePath, contents, False);" + LineEnding;
  Result += "  DeleteFile(filePath + '.bak');" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function DirectoryIsEmpty(const directory: String): Boolean;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Result := (FindFiles(directory, False) = []) and (FindDirectories(directory, False) = []);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function DeleteFiles(const directory: String; skip: TStringArray = []): Boolean;" + LineEnding;
  Result += "  function _SkipFile(dir: String): Boolean;" + LineEnding;
  Result += "  var" + LineEnding;
  Result += "    s: String;" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    for s in skip do" + LineEnding;
  Result += "      if Pos(s, dir) > 0 then" + LineEnding;
  Result += "        Exit(True);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "var" + LineEnding;
  Result += "  f: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for f in FindFiles(directory, True) do" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    if _SkipFile(f) then" + LineEnding;
  Result += "      Continue;" + LineEnding + LineEnding;
  Result += "    if not DeleteFile(f) then" + LineEnding;
  Result += "      Exit;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  Result := True;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function DeleteSubDirectories(const directory: String; deleteRoot: Boolean; skip: TStringArray = []): Boolean;" + LineEnding + LineEnding;
  Result += "  function _SkipDirectory(dir: String): Boolean;" + LineEnding;
  Result += "  var" + LineEnding;
  Result += "    s: String;" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    for s in skip do" + LineEnding;
  Result += "      if Pos(s, dir) > 0 then" + LineEnding;
  Result += "        Exit(True);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  function _GetParent(dir: String): String;" + LineEnding;
  Result += "  var" + LineEnding;
  Result += "    strings: TStringArray;" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    strings := Explode(DirectorySeparator, dir);" + LineEnding;
  Result += "    SetLength(strings, High(strings));" + LineEnding;
  Result += "    Result := strings.Merge(DirectorySeparator);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "var" + LineEnding;
  Result += "  directories, parents: TStringArray;" + LineEnding;
  Result += "  i: Int32;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  directories := FindDirectories(directory, True);" + LineEnding + LineEnding;
  Result += "  while directories <> [] do" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    for i := High(directories) downto 0 do" + LineEnding;
  Result += "    begin" + LineEnding;
  Result += "      if _SkipDirectory(directories[i]) then" + LineEnding;
  Result += "      begin" + LineEnding;
  Result += "        parents += _GetParent(directories[i]);" + LineEnding;
  Result += "        Delete(directories, i, 1);" + LineEnding;
  Result += "        deleteRoot := False;" + LineEnding;
  Result += "        Continue;" + LineEnding;
  Result += "      end;" + LineEnding + LineEnding;
  Result += "      if not parents.Contains(directories[i]) and not DeleteDirectory(directories[i], False) then" + LineEnding;
  Result += "        Exit;" + LineEnding;
  Result += "      Delete(directories, i, 1);" + LineEnding;
  Result += "    end;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  Result := not deleteRoot or DeleteDirectory(directory, False);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function RMDir(const directory: String; deleteRoot: Boolean; skip: TStringArray = []): Boolean;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if not DeleteFiles(directory, skip) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  Result := DeleteSubDirectories(directory, deleteRoot, skip);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "function IsFileLocked(path: String): Boolean;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if not FileExists(path) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  if not BackupFile(path) then" + LineEnding;
  Result += "    TerminateScript('Failed to backup file: ' + path);" + LineEnding + LineEnding;
  Result += "  Result := not DeleteFile(path);" + LineEnding + LineEnding;
  Result += "  if Result then" + LineEnding;
  Result += "    DeleteFile(path + '.bak')" + LineEnding;
  Result += "  else if not RestoreFile(path) then" + LineEnding;
  Result += "    TerminateScript('Failed to restore file: ' + path);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function FindLockedPlugins(): TStringArray;" + LineEnding;
  Result += "const" + LineEnding;
  Result += "  PATHS = [" + LineEnding;
  Result += "    IncludePath + 'SRL'   + SEP + 'plugins' + SEP + 'libremoteinput' + SEP," + LineEnding;
  Result += "    IncludePath + 'SRL-T' + SEP + 'plugins' + SEP + 'libremoteinput' + SEP" + LineEnding;
  Result += "  ];" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  path, plugin: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for path in PATHS do" + LineEnding;
  Result += "    for plugin in FindFiles(path, False) do" + LineEnding;
  Result += "      if IsFileLocked(plugin) then" + LineEnding;
  Result += "        Result += plugin;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "procedure KillWindowByClass(name: String);" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  window: TOSWindow;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for window in GetWindows().GetByClass(name) do" + LineEnding;
  Result += "    window.Kill();" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure KillSimbas();" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  windows, simbas: TOSWindowArray;" + LineEnding;
  Result += "  win: TOSWindow;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  windows := GetWindows();" + LineEnding;
  Result += "  simbas := windows.GetByTitleAndClass('Output,File Browser,Editor,Function List', 'Window');" + LineEnding + LineEnding;
  Result += "  if MessageDlg('Close Simba', 'Simba needs to be restarted.'," + LineEnding;
  Result += "     TMsgDlgType.mtConfirmation, [mbOK, mbAbort]) = 3 then" + LineEnding;
  Result += "    TerminateScript('You need to close all Simba windows to update SRL.');" + LineEnding + LineEnding;
  Result += "  for win in simbas do" + LineEnding;
  Result += "    win.Kill();" + LineEnding + LineEnding;
  Result += "  TerminateScript();" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "procedure UnlockPlugins();" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  locked: TStringArray;" + LineEnding;
  Result += "  plugin: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  locked := FindLockedPlugins();" + LineEnding;
  Result += "  if locked = [] then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  if MessageDlg('Close RuneScape', 'RS Clients need to be closed to update this package.'," + LineEnding;
  Result += "     TMsgDlgType.mtConfirmation, [mbOK, mbAbort]) = 3 then" + LineEnding;
  Result += "    TerminateScript('You need to close your RS Clients to update SRL.');" + LineEnding + LineEnding;
  Result += "  KillWindowByClass('SunAwtCanvas');" + LineEnding + LineEnding;
  Result += "  for plugin in locked do" + LineEnding;
  Result += "    if IsFileLocked(plugin) then" + LineEnding;
  Result += "    begin" + LineEnding;
  Result += "      KillWindowByClass('Jagex Launcher');" + LineEnding;
  Result += "      Break;" + LineEnding;
  Result += "    end;" + LineEnding + LineEnding;
  Result += "  for plugin in locked do" + LineEnding;
  Result += "    if IsFileLocked(plugin) then" + LineEnding;
  Result += "    begin" + LineEnding;
  Result += "      KillSimbas();" + LineEnding;
  Result += "      Break;" + LineEnding;
  Result += "    end;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "procedure MoveFiles(origin, pkg: String);" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  paths, files: TStringArray;" + LineEnding;
  Result += "  path, f, fPath, destination: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  paths := GetDirectories(origin + pkg + SEP);" + LineEnding;
  Result += "  if Length(paths) <> 1 then" + LineEnding;
  Result += "    TerminateScript('The ' + pkg + ' download is empty or has unexpected things inside.');" + LineEnding + LineEnding;
  Result += "  destination := IncludePath + pkg + SEP;" + LineEnding;
  Result += "  if DirectoryExists(destination) and not RMDir(destination, True, ['.git', 'overrides.simba']) then" + LineEnding;
  Result += "    TerminateScript('Failed to delete old ' + pkg + ' library');" + LineEnding;
  Result += "  if not ForceDirectories(destination) then" + LineEnding;
  Result += "    TerminateScript('Failed to create path: ' + destination);" + LineEnding + LineEnding;
  Result += "  path := origin + pkg + SEP + paths[0] + SEP;" + LineEnding;
  Result += "  files := FindFiles(path, True);" + LineEnding + LineEnding;
  Result += "  for f in files do" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    fPath := Replace(f, path, '', [rfReplaceAll]);" + LineEnding;
  Result += "    if Pos('.git', fPath) > 0 then" + LineEnding;
  Result += "      Continue;" + LineEnding + LineEnding;
  Result += "    if Pos('overrides.simba', fPath) > 0 then" + LineEnding;
  Result += "      Continue;" + LineEnding + LineEnding;
  Result += "    if not ForceDirectories(destination + ExtractFilePath(fPath)) then" + LineEnding;
  Result += "      TerminateScript('Failed to create path: ' + destination + ExtractFilePath(fPath));" + LineEnding + LineEnding;
  Result += "    if not CopyFile(f, destination + fPath, False) then" + LineEnding;
  Result += "      TerminateScript('Failed to copy file: ' + fPath);" + LineEnding + LineEnding;
  Result += "    DeleteFile(f);" + LineEnding;
  Result += "    if (FindFiles(ExtractFilePath(f), True) = []) and (FindDirectories(ExtractFilePath(f), True) = []) then" + LineEnding;
  Result += "      DeleteDirectory(ExtractFilePath(f), False);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  RMDir(origin + pkg, True);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "var" + LineEnding;
  Result += "  pkg: String;" + LineEnding + LineEnding;
  Result += "procedure Free();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  CloseFile(CreateFile({$MACRO CURRENT_DIRECTORY} + 'mover-' + LowerCase(pkg) + '.done'));" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  pkg := GetProcessParameter('pkg');" + LineEnding + LineEnding;
  Result += "  if FileExists({$MACRO CURRENT_DIRECTORY} + 'mover-' + LowerCase(pkg) + '.done') then" + LineEnding;
  Result += "    DeleteFile({$MACRO CURRENT_DIRECTORY} + 'mover-' + LowerCase(pkg) + '.done');" + LineEnding + LineEnding;
  Result += "  AddOnTerminate(@Free);" + LineEnding + LineEnding;
  Result += "  case LowerCase(pkg) of" + LineEnding;
  Result += "    'srl-t', 'srlt', 'srl': UnlockPlugins();" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  WriteLn('[AsyncMover]: Moving ', pkg, ' files, this will take a while.');" + LineEnding;
  Result += "  MoveFiles(GetProcessParameter('origin'), pkg);" + LineEnding;
  Result += "end;" + LineEnding;
end;

function TWaspAsync.GetServerContent(): String;
begin
  Result += "//Credits: Slacky" + LineEnding;
  Result += "function String.After(SubStr: String; p: Int32): String; constref;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Inc(p, Length(SubStr));" + LineEnding;
  Result += "  Result := Copy(Self, p, Length(Self) - p + 1);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "type" + LineEnding;
  Result += "  TSimbaServerClient = record" + LineEnding;
  Result += "    ID: Int32;" + LineEnding;
  Result += "    IP, Port: String;" + LineEnding;
  Result += "    IsSetup: Boolean;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  TSimbaServer = record" + LineEnding;
  Result += "    ID: Int32;" + LineEnding;
  Result += "    IP, Port: String;" + LineEnding;
  Result += "    Client: TSimbaServerClient;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "procedure TSimbaServerClient.CloseAndFree();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if not Self.IsSetup then Exit;" + LineEnding;
  Result += "  CloseSocket(Self.ID);" + LineEnding;
  Result += "  FreeSocket(Self.ID);" + LineEnding;
  Result += "  Self.IsSetup := False;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure TSimbaServerClient.WriteString(s: string);" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  SendSocket(Self.ID, s);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TSimbaServerClient.SendHTML(content: String): Boolean;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  headers, html: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  html :=" + LineEnding;
  Result += "  '<!DOCTYPE html>' + LineEnding +" + LineEnding;
  Result += "    '<html>' + LineEnding +" + LineEnding;
  Result += "    '  <head>' + LineEnding +" + LineEnding;
  Result += "    '    <meta charset=''UTF-8''>' + LineEnding +" + LineEnding;
  Result += "    '    <link rel=''icon'' href=''https://waspscripts.com/favicon.png''>' + LineEnding +" + LineEnding;
  Result += "    '    <meta name=''viewport'' content=''width=device-width''>' + LineEnding +" + LineEnding;
  Result += "    '    <title>WaspScripts</title>'  + LineEnding +" + LineEnding;
  Result += "    '    <meta name=''description'' content=''WaspScripts Simba Login page''>' + LineEnding +" + LineEnding;
  Result += "    '    <style>' + LineEnding +" + LineEnding;
  Result += "    '      body {' + LineEnding +" + LineEnding;
  Result += "    '         background-color: #222324;' + LineEnding +" + LineEnding;
  Result += "    '         color: white;' + LineEnding +" + LineEnding;
  Result += "    '         display: flex;' + LineEnding +" + LineEnding;
  Result += "    '         justify-content: center;' + LineEnding +" + LineEnding;
  Result += "    '         height: 100vh;' + LineEnding +" + LineEnding;
  Result += "    '         text-align: center;' + LineEnding +" + LineEnding;
  Result += "    '         flex-direction: column;' + LineEnding +" + LineEnding;
  Result += "    '      }' + LineEnding +" + LineEnding;
  Result += "    '    </style>' + LineEnding +" + LineEnding + LineEnding;
  Result += "    '  </head>' + LineEnding +" + LineEnding;
  Result += "    ' <body>' + LineEnding +" + LineEnding;
  Result += "        content + LineEnding +" + LineEnding;
  Result += "    ' </body>' + LineEnding +" + LineEnding;
  Result += "  '</html>';" + LineEnding + LineEnding;
  Result += "  headers += 'HTTP/1.1 200 OK' + #13#10;" + LineEnding;
  Result += "  headers += 'Content-Type: text/html'+#13#10;" + LineEnding;
  Result += "  headers += 'Connection: close'+#13#10;" + LineEnding;
  Result += "  headers += 'Content-Length: ' + IntToStr(Length(html))+#13#10#13#10;" + LineEnding + LineEnding;
  Result += "  Result := True;" + LineEnding;
  Result += "  try" + LineEnding;
  Result += "    Self.WriteString(headers + html);" + LineEnding;
  Result += "  except" + LineEnding;
  Result += "    Exit(False);" + LineEnding;
  Result += "  end;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "function TSimbaServerClient.Read(): String; overload;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Result := RecvSocketStr(Self.ID);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "procedure TSimbaServer.CloseAndFree();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  CloseSocket(Self.ID);" + LineEnding;
  Result += "  FreeSocket(Self.ID);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TSimbaServer.AttemptSocketBind(): Boolean;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  try BindSocket(Self.ID, Self.IP, Self.Port); except Exit end;" + LineEnding;
  Result += "  Result := True;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure TSimbaServer.Setup();" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  attempt: Int32;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Self.ID   := CreateSocket();" + LineEnding;
  Result += "  Self.IP   := '127.0.0.1';" + LineEnding;
  Result += "  Self.Port := '5217';" + LineEnding + LineEnding;
  Result += "  for attempt := 0 to 200 do" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    if Self.AttemptSocketBind() then Break;" + LineEnding;
  Result += "    Sleep(100);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  ListenSocket(Self.ID);" + LineEnding;
  Result += "  Self.Client.ID := -1;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure TSimbaServer.AcceptClient();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Self.Client.IsSetup := True;" + LineEnding;
  Result += "  Self.Client.ID := AcceptSocket(Self.ID);" + LineEnding;
  Result += "  SocketInfo(Self.Client.ID, Self.Client.IP, Self.Client.Port);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TSimbaServer.Listen(): String;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  tmp, header, path: String;" + LineEnding;
  Result += "  i: Int32" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  try SetSocketTimeout(Self.Client.ID, 2000); except Exit; end;" + LineEnding + LineEnding;
  Result += "  //Writeln('Connection from: ', client.IP, ':', client.Port);" + LineEnding + LineEnding;
  Result += "  repeat" + LineEnding;
  Result += "    try" + LineEnding;
  Result += "      tmp := Self.Client.Read();" + LineEnding;
  Result += "      header += tmp;" + LineEnding;
  Result += "    except" + LineEnding;
  Result += "      Exit; //client is DC'ed." + LineEnding;
  Result += "    end;" + LineEnding;
  Result += "  until tmp = '';" + LineEnding + LineEnding;
  Result += "  path := Between('GET ', ' HTTP/1.1', header);" + LineEnding + LineEnding;
  Result += "  i := Pos('?error=', path);" + LineEnding;
  Result += "  if i > 0 then" + LineEnding;
  Result += "    if not client.SendHTML('<h1>Login failed with error message:</h1><p>' + path.After('?error=', i) + '</p><h2>Close this page and try again.</h2>') then Exit;" + LineEnding + LineEnding;
  Result += "  i := Pos('?code=', path);" + LineEnding;
  Result += "  if i > 0 then" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    Result := path.After('?code=', i);" + LineEnding;
  Result += "    if not Self.Client.SendHTML('<h1>You''ve successfully logged in!</h1><h2>You can now close this page.</h2>') then Exit;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  Self.Client.CloseAndFree();" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "var" + LineEnding;
  Result += "  HealthChecker: TTimer;" + LineEnding;
  Result += "  Timeout: UInt64;" + LineEnding;
  Result += "  Server: TSimbaServer;" + LineEnding;
  Result += "  {$IFDEF SIMBAHEADLESS}" + LineEnding;
  Result += "  LauncherPID: PtrUInt;" + LineEnding;
  Result += "  {$ENDIF}" + LineEnding;
  Result += "  Code: String;" + LineEnding + LineEnding;
  Result += "procedure HealthCheck(sender: TObject);" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if (GetTickCount() <= Timeout) and" + LineEnding;
  Result += "      {$IFDEF SIMBAHEADLESS} IsProcessRunning(LauncherPID) and {$ENDIF}" + LineEnding;
  Result += "      not FileExists({$macro CURRENT_DIRECTORY} + 'server-stop') then Exit;" + LineEnding + LineEnding;
  Result += "  DeleteFile({$macro CURRENT_DIRECTORY} + 'server-stop');" + LineEnding;
  Result += "  CloseFile(CreateFile({$macro CURRENT_DIRECTORY} + 'server-failed.done'));" + LineEnding + LineEnding;
  Result += "  TTimer(sender).setEnabled(False);" + LineEnding;
  Result += "  RaiseException('Server timed out!');" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure RunHealthCheck();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  HealthChecker.SetOnTimer(@HealthCheck);" + LineEnding;
  Result += "  HealthChecker.SetEnabled(True);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  DeleteFile({$macro CURRENT_DIRECTORY} + 'server-stop');" + LineEnding;
  Result += "  {$IFDEF SIMBAHEADLESS}" + LineEnding;
  Result += "  LauncherPID := Variant(GetProcessParameter('LauncherPID'));" + LineEnding;
  Result += "  {$ENDIF}" + LineEnding + LineEnding;
  Result += "  Server.Setup();" + LineEnding;
  Result += "  AddOnTerminate(@Server.CloseAndFree);" + LineEnding;
  Result += "  AddOnTerminate(@Server.Client.CloseAndFree);" + LineEnding;
  Result += "  AddOnTerminate(@HealthChecker.Free);" + LineEnding + LineEnding;
  Result += "  Timeout := GetTickCount() + 5 * 60 * 1000;" + LineEnding;
  Result += "  HealthChecker.Init(nil);" + LineEnding + LineEnding;
  Result += "  HealthChecker.SetInterval(150);" + LineEnding;
  Result += "  Sync(@RunHealthCheck);" + LineEnding + LineEnding;
  Result += "  repeat" + LineEnding;
  Result += "    Server.AcceptClient();" + LineEnding;
  Result += "    code := Server.Listen();" + LineEnding;
  Result += "  until code <> '';" + LineEnding + LineEnding;
  Result += "  WriteFileContents({$macro CURRENT_DIRECTORY} + 'server-success.done', code, False);" + LineEnding + LineEnding;
  Result += "  HealthChecker.setEnabled(False);" + LineEnding;
  Result += "end;" + LineEnding;
end;

procedure TWaspAsync.Setup();
begin
  Self.Path := LAUNCHER_DATA + 'async' + DirectorySeparator;

  if not ForceDirectories(LAUNCHER_DATA) then
    TerminateScript('WaspAsync failed to create directory: ' + LAUNCHER_DATA);

  if DirectoryExists(Self.Path) and not RMDir(Self.Path, True) then
    TerminateScript('WaspAsync failed to delete old files. Please manually delete:' + Self.Path);

  if DirectoryExists(LAUNCHER_DATA + 'downloads') and not RMDir(LAUNCHER_DATA + 'downloads') then
    TerminateScript('WaspAsync failed to delete old files. Please manually delete: ' + LAUNCHER_DATA + 'downloads' + DirectorySeparator);

  if not ForceDirectories(Self.Path) then
    TerminateScript('WaspAsync can''t create async directory.');

  Self.Write('downloader.simba', Self.GetDownloaderContent());
  Self.Write('unzipper.simba', Self.GetUnzipperContent());
  Self.Write('mover.simba', Self.GetMoverContent());
  Self.Write('server.simba', Self.GetServerContent());
end;

var
  WaspAsync: TWaspAsync;
