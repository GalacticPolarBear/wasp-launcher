{$DEFINE WS_ASYNC_INCLUDED}
{$IFNDEF WS_LAUNCHER}
  {$I core.simba}
{$ENDIF}

type
  EMonitorState = (NONE, DOWNLOAD, UNZIP, CLEAN);

  TMonitor = record
    Package: String;
    CurrentFile: String;
    State: EMonitorState;
    IsSetup: Boolean;

    Caption: TLabel;
    Button: TButton;
    Timer: TTimer;
  end;

  TWaspAsync = record
    Path: String;
  end;

procedure TWaspAsync.Write(name, content: String);
begin
  if not WriteFileContents(Self.Path + name, content, False) then
    TerminateScript('WaspAsync: Failed to write async file: ' + name);
end;

procedure TWaspAsync.Run(name: String; params: TStringArray);
begin
  if not name.EndsWith('.simba') then
    name += '.simba';
  RunScript(Self.Path + name, params);
end;


function TWaspAsync.GetDownloaderContent(): String;
begin
  Result += "var" + LineEnding;
  Result += "  timeout: TTimer;" + LineEnding;
  Result += "  http: Int32;" + LineEnding;
  Result += "  url, pkg: String;" + LineEnding;
  Result += "  t: UInt64;" + LineEnding + LineEnding;
  Result += "procedure OnTimer({$H-}sender: TObject);{$H+}" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  WriteLn('[AsyncDownloader]: Downloading ', pkg, '...');" + LineEnding + LineEnding;
  Result += "  if GetTickCount() > t then" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    WriteLn('[AsyncDownloader]: If this has taken over 5 minutes please restart Simba.');" + LineEnding;
  Result += "    WriteLn('[AsyncDownloader]: If you are rate limited you need to wait 1 hour.');" + LineEnding;
  Result += "    t := GetTickCount() + 120000;" + LineEnding;
  Result += "  end;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure Free();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  timeout.setEnabled(False);" + LineEnding;
  Result += "  timeout.Free();" + LineEnding;
  Result += "  FreeHTTPClient(http);" + LineEnding;
  Result += "  CloseFile(CreateFile({$macro CURRENT_DIRECTORY} + 'downloader-' + LowerCase(pkg) + '.done'));" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure RunTimer();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  timeout.setOnTimer(@OnTimer);" + LineEnding;
  Result += "  timeout.setEnabled(True);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  url := GetProcessParameter('url');" + LineEnding;
  Result += "  pkg := GetProcessParameter('pkg');" + LineEnding + LineEnding;
  Result += "  if FileExists({$macro CURRENT_DIRECTORY} + 'downloader-' + LowerCase(pkg) + '.done') then" + LineEnding;
  Result += "    DeleteFile({$macro CURRENT_DIRECTORY} + 'downloader-' + LowerCase(pkg) + '.done');" + LineEnding + LineEnding;
  Result += "  timeout.Init(nil);" + LineEnding;
  Result += "  timeout.SetName('downloader_timeout');" + LineEnding;
  Result += "  timeout.SetInterval(20000);" + LineEnding;
  Result += "  http := InitializeHTTPClient(True);" + LineEnding;
  Result += "  Sync(@RunTimer);" + LineEnding;
  Result += "  AddOnTerminate(@Free);" + LineEnding + LineEnding;
  Result += "  WriteLn('[AsyncDownloader]: Downloading ', pkg, ', this might take a while.');" + LineEnding;
  Result += "  t := GetTickCount() + 120000;" + LineEnding + LineEnding;
  Result += "  try" + LineEnding;
  Result += "    if GetHTTPPageEx(http, url, GetProcessParameter('destination')) = 200 then" + LineEnding;
  Result += "      WriteLn('[AsyncDownloader]: ' + pkg + ' downloaded.')" + LineEnding;
  Result += "    else" + LineEnding;
  Result += "      WriteLn('[AsyncDownloader]: Failed to download: ' + url);" + LineEnding;
  Result += "  except" + LineEnding;
  Result += "    WriteLn('[AsyncDownloader]: Error: ', GetExceptionMessage());" + LineEnding;
  Result += "  end;" + LineEnding;
  Result += "end;" + LineEnding;
end;

function TWaspAsync.GetUnzipperContent(): String;
begin
  Result += "var" + LineEnding;
  Result += "  path, name: String;" + LineEnding + LineEnding;
  Result += "procedure Free();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  CloseFile(CreateFile({$macro CURRENT_DIRECTORY} + 'unzipper-' + LowerCase(name) + '.done'));" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  path := GetProcessParameter('path');" + LineEnding;
  Result += "  name := GetProcessParameter('name');" + LineEnding + LineEnding;
  Result += "  if FileExists({$macro CURRENT_DIRECTORY} + 'downloader-' + LowerCase(name) + '.done') then" + LineEnding;
  Result += "    DeleteFile({$macro CURRENT_DIRECTORY} + 'downloader-' + LowerCase(name) + '.done');" + LineEnding + LineEnding;
  Result += "  AddOnTerminate(@Free);" + LineEnding + LineEnding;
  Result += "  WriteLn('[AsyncUnzipper]: Unzipping ', name, ', this might take a while.');" + LineEnding + LineEnding;
  Result += "  try" + LineEnding;
  Result += "    UnZipFile(path + name + '.zip', path + name);" + LineEnding;
  Result += "    DeleteFile(path + name + '.zip');" + LineEnding;
  Result += "  except" + LineEnding;
  Result += "    WriteLn('[AsyncUnzipper]: Error: ', GetExceptionMessage());" + LineEnding;
  Result += "  end;" + LineEnding;
  Result += "end;" + LineEnding;
end;

function TWaspAsync.GetMoverContent(): String;
begin
  Result += "const" + LineEnding;
  Result += "  SEP = DirectorySeparator;" + LineEnding + LineEnding;
  Result += "procedure TerminateScript(reason: String); overload;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  WriteLn('[AsyncMover]: Terminating: ' + reason);" + LineEnding;
  Result += "  TerminateScript();" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "function TStringArray.Find(const value: String): Integer; constref;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for Result := 0 to High(Self) do" + LineEnding;
  Result += "    if value = Self[Result] then" + LineEnding;
  Result += "      Exit;" + LineEnding;
  Result += "  Result := -1;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TStringArray.Contains(const value: String): Boolean; constref;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Result := Self.Find(value) > -1;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function TStringArray.Merge(glue:String=''): String; constref;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  i:Int32;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if Length(Self) = 0 then" + LineEnding;
  Result += "    Exit();" + LineEnding + LineEnding;
  Result += "  Result := Self[0];" + LineEnding;
  Result += "  for i:=1 to High(Self) do" + LineEnding;
  Result += "    Result += glue + Self[i];" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function BackupFile(filePath: String): Boolean;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  f: Int32;" + LineEnding;
  Result += "  contents: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  f := OpenFile(filePath, False);" + LineEnding;
  Result += "  if not ReadFileString(f, contents, FileSize(f)) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  CloseFile(f);" + LineEnding;
  Result += "  Result := WriteFileContents(filePath + '.bak', contents, False);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function RestoreFile(filePath: String): Boolean;" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  f: Int32;" + LineEnding;
  Result += "  contents: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  f := OpenFile(filePath + '.bak', False);" + LineEnding;
  Result += "  if not ReadFileString(f, contents, FileSize(f)) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  CloseFile(f);" + LineEnding;
  Result += "  Result := WriteFileContents(filePath, contents, False);" + LineEnding;
  Result += "  DeleteFile(filePath + '.bak');" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function DirectoryIsEmpty(const directory: String): Boolean;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  Result := (FindFiles(directory, False) = []) and (FindDirectories(directory, False) = []);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function DeleteFiles(const directory: String; skip: TStringArray = []): Boolean;" + LineEnding;
  Result += "  function _SkipFile(dir: String): Boolean;" + LineEnding;
  Result += "  var" + LineEnding;
  Result += "    s: String;" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    for s in skip do" + LineEnding;
  Result += "      if Pos(s, dir) > 0 then" + LineEnding;
  Result += "        Exit(True);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "var" + LineEnding;
  Result += "  f: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for f in FindFiles(directory, True) do" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    if _SkipFile(f) then" + LineEnding;
  Result += "      Continue;" + LineEnding + LineEnding;
  Result += "    if not DeleteFile(f) then" + LineEnding;
  Result += "      Exit;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  Result := True;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function DeleteSubDirectories(const directory: String; deleteRoot: Boolean; skip: TStringArray = []): Boolean;" + LineEnding + LineEnding;
  Result += "  function _SkipDirectory(dir: String): Boolean;" + LineEnding;
  Result += "  var" + LineEnding;
  Result += "    s: String;" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    for s in skip do" + LineEnding;
  Result += "      if Pos(s, dir) > 0 then" + LineEnding;
  Result += "        Exit(True);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  function _GetParent(dir: String): String;" + LineEnding;
  Result += "  var" + LineEnding;
  Result += "    strings: TStringArray;" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    strings := Explode(DirectorySeparator, dir);" + LineEnding;
  Result += "    SetLength(strings, High(strings));" + LineEnding;
  Result += "    Result := strings.Merge(DirectorySeparator);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "var" + LineEnding;
  Result += "  directories, parents: TStringArray;" + LineEnding;
  Result += "  i: Int32;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  directories := FindDirectories(directory, True);" + LineEnding + LineEnding;
  Result += "  while directories <> [] do" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    for i := High(directories) downto 0 do" + LineEnding;
  Result += "    begin" + LineEnding;
  Result += "      if _SkipDirectory(directories[i]) then" + LineEnding;
  Result += "      begin" + LineEnding;
  Result += "        parents += _GetParent(directories[i]);" + LineEnding;
  Result += "        Delete(directories, i, 1);" + LineEnding;
  Result += "        deleteRoot := False;" + LineEnding;
  Result += "        Continue;" + LineEnding;
  Result += "      end;" + LineEnding + LineEnding;
  Result += "      if not parents.Contains(directories[i]) and not DeleteDirectory(directories[i], False) then" + LineEnding;
  Result += "        Exit;" + LineEnding;
  Result += "      Delete(directories, i, 1);" + LineEnding;
  Result += "    end;" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  Result := not deleteRoot or DeleteDirectory(directory, False);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function RMDir(const directory: String; deleteRoot: Boolean; skip: TStringArray = []): Boolean;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if not DeleteFiles(directory, skip) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  Result := DeleteSubDirectories(directory, deleteRoot, skip);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "function IsFileLocked(path: String): Boolean;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  if not FileExists(path) then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  if not BackupFile(path) then" + LineEnding;
  Result += "    TerminateScript('Failed to backup file: ' + path);" + LineEnding + LineEnding;
  Result += "  Result := not DeleteFile(path);" + LineEnding + LineEnding;
  Result += "  if Result then" + LineEnding;
  Result += "    DeleteFile(path + '.bak')" + LineEnding;
  Result += "  else if not RestoreFile(path) then" + LineEnding;
  Result += "    TerminateScript('Failed to restore file: ' + path);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "function FindLockedPlugins(): TStringArray;" + LineEnding;
  Result += "const" + LineEnding;
  Result += "  PATHS = [" + LineEnding;
  Result += "    IncludePath + 'SRL'   + SEP + 'plugins' + SEP + 'libremoteinput' + SEP," + LineEnding;
  Result += "    IncludePath + 'SRL-T' + SEP + 'plugins' + SEP + 'libremoteinput' + SEP" + LineEnding;
  Result += "  ];" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  path, plugin: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for path in PATHS do" + LineEnding;
  Result += "    for plugin in FindFiles(path, False) do" + LineEnding;
  Result += "      if IsFileLocked(plugin) then" + LineEnding;
  Result += "        Result += plugin;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "procedure KillWindowByClass(name: String);" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  window: TOSWindow;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  for window in GetWindows().GetByClass(name) do" + LineEnding;
  Result += "    window.Kill();" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "procedure KillSimbas();" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  windows, simbas: TOSWindowArray;" + LineEnding;
  Result += "  win: TOSWindow;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  windows := GetWindows();" + LineEnding;
  Result += "  simbas := windows.GetByTitleAndClass('Output,File Browser,Editor,Function List', 'Window');" + LineEnding + LineEnding;
  Result += "  if MessageDlg('Close Simba', 'Simba needs to be restarted.'," + LineEnding;
  Result += "     TMsgDlgType.mtConfirmation, [mbOK, mbAbort]) = 3 then" + LineEnding;
  Result += "    TerminateScript('You need to close all Simba windows to update SRL.');" + LineEnding + LineEnding;
  Result += "  for win in simbas do" + LineEnding;
  Result += "    win.Kill();" + LineEnding + LineEnding;
  Result += "  TerminateScript();" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "procedure UnlockPlugins();" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  locked: TStringArray;" + LineEnding;
  Result += "  plugin: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  locked := FindLockedPlugins();" + LineEnding;
  Result += "  if locked = [] then" + LineEnding;
  Result += "    Exit;" + LineEnding + LineEnding;
  Result += "  if MessageDlg('Close RuneScape', 'RS Clients need to be closed to update this package.'," + LineEnding;
  Result += "     TMsgDlgType.mtConfirmation, [mbOK, mbAbort]) = 3 then" + LineEnding;
  Result += "    TerminateScript('You need to close your RS Clients to update SRL.');" + LineEnding + LineEnding;
  Result += "  KillWindowByClass('SunAwtCanvas');" + LineEnding + LineEnding;
  Result += "  for plugin in locked do" + LineEnding;
  Result += "    if IsFileLocked(plugin) then" + LineEnding;
  Result += "    begin" + LineEnding;
  Result += "      KillWindowByClass('Jagex Launcher');" + LineEnding;
  Result += "      Break;" + LineEnding;
  Result += "    end;" + LineEnding + LineEnding;
  Result += "  for plugin in locked do" + LineEnding;
  Result += "    if IsFileLocked(plugin) then" + LineEnding;
  Result += "    begin" + LineEnding;
  Result += "      KillSimbas();" + LineEnding;
  Result += "      Break;" + LineEnding;
  Result += "    end;" + LineEnding;
  Result += "end;" + LineEnding + LineEnding + LineEnding;
  Result += "procedure MoveFiles(origin, pkg: String);" + LineEnding;
  Result += "var" + LineEnding;
  Result += "  paths, files: TStringArray;" + LineEnding;
  Result += "  path, f, fPath, destination: String;" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  paths := GetDirectories(origin + pkg + SEP);" + LineEnding;
  Result += "  if Length(paths) <> 1 then" + LineEnding;
  Result += "    TerminateScript('The ' + pkg + ' download is empty or has unexpected things inside.');" + LineEnding + LineEnding;
  Result += "  destination := IncludePath + pkg + SEP;" + LineEnding;
  Result += "  if DirectoryExists(destination) and not RMDir(destination, True, ['.git', 'overrides.simba']) then" + LineEnding;
  Result += "    TerminateScript('Failed to delete old ' + pkg + ' library');" + LineEnding;
  Result += "  if not ForceDirectories(destination) then" + LineEnding;
  Result += "    TerminateScript('Failed to create path: ' + destination);" + LineEnding + LineEnding;
  Result += "  path := origin + pkg + SEP + paths[0] + SEP;" + LineEnding;
  Result += "  files := FindFiles(path, True);" + LineEnding + LineEnding;
  Result += "  for f in files do" + LineEnding;
  Result += "  begin" + LineEnding;
  Result += "    fPath := Replace(f, path, '', [rfReplaceAll]);" + LineEnding;
  Result += "    if Pos('.git', fPath) > 0 then" + LineEnding;
  Result += "      Continue;" + LineEnding + LineEnding;
  Result += "    if not ForceDirectories(destination + ExtractFilePath(fPath)) then" + LineEnding;
  Result += "      TerminateScript('Failed to create path: ' + destination + ExtractFilePath(fPath));" + LineEnding + LineEnding;
  Result += "    if not CopyFile(f, destination + fPath, False) then" + LineEnding;
  Result += "      TerminateScript('Failed to copy file: ' + fPath);" + LineEnding + LineEnding;
  Result += "    DeleteFile(f);" + LineEnding;
  Result += "    if (FindFiles(ExtractFilePath(f), True) = []) and (FindDirectories(ExtractFilePath(f), True) = []) then" + LineEnding;
  Result += "      DeleteDirectory(ExtractFilePath(f), False);" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  RMDir(origin + pkg, True);" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "var" + LineEnding;
  Result += "  pkg: String;" + LineEnding + LineEnding;
  Result += "procedure Free();" + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  CloseFile(CreateFile({$MACRO CURRENT_DIRECTORY} + 'mover-' + LowerCase(pkg) + '.done'));" + LineEnding;
  Result += "end;" + LineEnding + LineEnding;
  Result += "begin" + LineEnding;
  Result += "  pkg := GetProcessParameter('pkg');" + LineEnding + LineEnding;
  Result += "  if FileExists({$MACRO CURRENT_DIRECTORY} + 'mover-' + LowerCase(pkg) + '.done') then" + LineEnding;
  Result += "    DeleteFile({$MACRO CURRENT_DIRECTORY} + 'mover-' + LowerCase(pkg) + '.done');" + LineEnding + LineEnding;
  Result += "  AddOnTerminate(@Free);" + LineEnding + LineEnding;
  Result += "  case LowerCase(pkg) of" + LineEnding;
  Result += "    'srl-t', 'srlt', 'srl': UnlockPlugins();" + LineEnding;
  Result += "  end;" + LineEnding + LineEnding;
  Result += "  WriteLn('[AsyncMover]: Moving ', pkg, ' files, this will take a while.');" + LineEnding;
  Result += "  MoveFiles(GetProcessParameter('origin'), pkg);" + LineEnding;
  Result += "end;" + LineEnding;
end;

procedure TWaspAsync.Setup();
begin
  Self.Path := LAUNCHER_DATA + 'async' + DirectorySeparator;

  if not ForceDirectories(LAUNCHER_DATA) then
    TerminateScript('WaspAsync failed to create directory: ' + LAUNCHER_DATA);

  if DirectoryExists(Self.Path) and not RMDir(Self.Path, True) then
    TerminateScript('WaspAsync failed to delete old files. Please manually delete:' + Self.Path);

  if DirectoryExists(LAUNCHER_DATA + 'downloads') and not RMDir(LAUNCHER_DATA + 'downloads') then
    TerminateScript('WaspAsync failed to delete old files. Please manually delete: ' + LAUNCHER_DATA + 'downloads' + DirectorySeparator);

  if not ForceDirectories(Self.Path) then
    TerminateScript('WaspAsync can''t create async directory.');

  Self.Write('downloader.simba', Self.GetDownloaderContent());
  Self.Write('unzipper.simba', Self.GetUnzipperContent());
  Self.Write('mover.simba', Self.GetMoverContent());
end;

var
  WaspAsync: TWaspAsync;
